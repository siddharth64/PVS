(hoare_logic_proofs
 (Proof?_TCC1 0
  (Proof?_TCC1-1 nil 3795086453 ("" (termination-tcc) nil nil) nil
   nil))
 (Proof?_TCC2 0
  (Proof?_TCC2-1 nil 3795086453 ("" (termination-tcc) nil nil) nil
   nil))
 (Proof?_TCC3 0
  (Proof?_TCC3-1 nil 3795086453 ("" (termination-tcc) nil nil) nil
   nil))
 (Proof?_TCC4 0
  (Proof?_TCC4-1 nil 3795086453 ("" (termination-tcc) nil nil) nil
   nil))
 (Proof?_TCC5 0
  (Proof?_TCC5-1 nil 3795086453 ("" (termination-tcc) nil nil) nil
   nil))
 (Proof?_TCC6 0
  (Proof?_TCC6-1 nil 3795086453 ("" (termination-tcc) nil nil)
   ((conseq const-decl "bool" hoare_triples nil)) nil))
 (check 0
  (check-1 nil 3795690297
   ("" (grind) (("" (rewrite "extensionality") nil nil)) nil)
   ((assertion type-eq-decl nil hoare_triples nil)
    (/\\ const-decl "bool" hoare_triples nil)
    (assignment type-eq-decl nil Hoare_logic nil)
    (value type-eq-decl nil Hoare_logic nil)
    (state type-eq-decl nil Hoare_logic nil))
   shostak))
 (checksswap_prf 0
  (checksswap_prf-1 nil 3795684586
   ("" (auto-rewrite-defs)
    (("" (assert)
      (("" (rewrite "extensionality")
        (("" (rewrite "extensionality") nil nil)) nil))
      nil))
    nil)
   ((x_gets_y const-decl "assignment" Hoare_logic nil)
    (/\\ const-decl "bool" hoare_triples nil)
    (state type-eq-decl nil Hoare_logic nil)
    (value type-eq-decl nil Hoare_logic nil)
    (a2 const-decl "assignment" Hoare_logic nil)
    (assignment type-eq-decl nil Hoare_logic nil)
    (assertion type-eq-decl nil hoare_triples nil))
   shostak))
 (r_gets_ry_TCC1 0
  (r_gets_ry_TCC1-1 nil 3798284572 ("" (subtype-tcc) nil nil) nil nil))
 (test1 0
  (test1-1 nil 3798287716
   ("" (grind)
    (("1" (apply-extensionality) nil nil)
     ("2" (apply-extensionality) nil nil)
     ("3" (apply-extensionality) (("3" (postpone) nil nil)) nil))
    nil)
   ((E const-decl "assertion" hoare_logic_proofs nil)
    (z_gets_0_step const-decl "preProof" hoare_logic_proofs nil)
    (aux_z0 const-decl "preProof" hoare_logic_proofs nil)
    (conseq const-decl "bool" hoare_triples nil)
    (Proof? def-decl "bool" hoare_logic_proofs nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (value type-eq-decl nil Hoare_logic nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (state type-eq-decl nil Hoare_logic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (O const-decl "T3" function_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (assignment type-eq-decl nil Hoare_logic nil)
    (z_gets_0 const-decl "assignment" hoare_logic_proofs nil))
   shostak))
 (check_div 0
  (check_div-1 nil 3798284572
   ("" (grind)
    (("1" (apply-extensionality) nil nil)
     ("2" (apply-extensionality) (("2" (grind) nil nil)) nil)
     ("3" (apply-extensionality) (("3" (grind) nil nil)) nil)
     ("4" (apply-extensionality) nil nil)
     ("5" (apply-extensionality) (("5" (grind) nil nil)) nil)
     ("6" (apply-extensionality) nil nil)
     ("7" (apply-extensionality) nil nil)
     ("8" (apply-extensionality) (("8" (grind) nil nil)) nil))
    nil)
   ((division const-decl "program" hoare_logic_proofs nil)
    (E const-decl "assertion" hoare_logic_proofs nil)
    (r_gets_x_step const-decl "preProof" hoare_logic_proofs nil)
    (z_gets_0_step const-decl "preProof" hoare_logic_proofs nil)
    (aux_z0 const-decl "preProof" hoare_logic_proofs nil)
    (One_pre const-decl "preProof" hoare_logic_proofs nil)
    (B const-decl "assertion" hoare_logic_proofs nil)
    (r_gets_ry_step const-decl "preProof" hoare_logic_proofs nil)
    (aux_r const-decl "preProof" hoare_logic_proofs nil)
    (incr_z_step const-decl "preProof" hoare_logic_proofs nil)
    (Two_pre const-decl "preProof" hoare_logic_proofs nil)
    (loop_step const-decl "preProof" hoare_logic_proofs nil)
    (aux_loop const-decl "preProof" hoare_logic_proofs nil)
    (div_pre const-decl "preProof" hoare_logic_proofs nil)
    (Proof? def-decl "bool" hoare_logic_proofs nil)
    (conseq const-decl "bool" hoare_triples nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (value type-eq-decl nil Hoare_logic nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (state type-eq-decl nil Hoare_logic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (O const-decl "T3" function_props nil)
    (assignment type-eq-decl nil Hoare_logic nil)
    (incr_z const-decl "assignment" hoare_logic_proofs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (r_gets_ry const-decl "assignment" hoare_logic_proofs nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (assertion type-eq-decl nil hoare_triples nil)
    (/\\ const-decl "bool" hoare_triples nil)
    (test type-eq-decl nil Hoare_logic nil)
    (~ const-decl "bool" hoare_triples nil)
    (test_con const-decl "test" hoare_logic_proofs nil)
    (z_gets_0 const-decl "assignment" hoare_logic_proofs nil)
    (TRUE const-decl "bool" booleans nil)
    (r_gets_x const-decl "assignment" hoare_logic_proofs nil))
   shostak))
 (soundness 0
  (soundness-1 nil 3798172957
   ("" (induct "M")
    (("1" (grind :rewrites "skip_rule") nil nil)
     ("2" (grind :rewrites "assign_rule") nil nil)
     ("3" (grind :if-match nil :exclude "triple_valid")
      (("3" (forward-chain "conditional_rule")
        (("3" (replace-eta "ift_step1_var!1`prog" "(ift?)") nil nil))
        nil))
      nil)
     ("4" (grind :if-match nil :exclude "triple_valid")
      (("4" (forward-chain "while_rule")
        (("4" (replace-eta "while_step1_var!1`prog" "(while?)") nil
          nil))
        nil))
      nil)
     ("5" (grind :if-match nil :exclude "triple_valid")
      (("5" (forward-chain "composition_rule")
        (("5" (replace-eta "seq_step1_var!1`prog" "(seq?)") nil nil))
        nil))
      nil)
     ("6" (grind :exclude ("triple_valid" "conseq"))
      (("6" (forward-chain "conseq_rule") nil nil)) nil))
    nil)
   ((conseq_rule formula-decl nil hoare_triples nil)
    (program_doublesharp_eta formula-decl nil Hoare_logic nil)
    (right adt-accessor-decl "[(seq?) -> program]" Hoare_logic nil)
    (left adt-accessor-decl "[(seq?) -> program]" Hoare_logic nil)
    (seq? adt-recognizer-decl "[program -> boolean]" Hoare_logic nil)
    (composition_rule formula-decl nil hoare_triples nil)
    (program_doubletimes_eta formula-decl nil Hoare_logic nil)
    (body adt-accessor-decl "[(while?) -> program]" Hoare_logic nil)
    (wcond adt-accessor-decl "[(while?) -> test]" Hoare_logic nil)
    (while? adt-recognizer-decl "[program -> boolean]" Hoare_logic nil)
    (while_rule formula-decl nil hoare_triples nil)
    (program_IF_eta formula-decl nil Hoare_logic nil)
    (elseprog adt-accessor-decl "[(ift?) -> program]" Hoare_logic nil)
    (thenprog adt-accessor-decl "[(ift?) -> program]" Hoare_logic nil)
    (ifcond adt-accessor-decl "[(ift?) -> test]" Hoare_logic nil)
    (ift? adt-recognizer-decl "[program -> boolean]" Hoare_logic nil)
    (test type-eq-decl nil Hoare_logic nil)
    (conditional_rule formula-decl nil hoare_triples nil)
    ([\|\|] def-decl "bool" Hoare_logic nil)
    (trace type-eq-decl nil Hoare_logic nil)
    (state type-eq-decl nil Hoare_logic nil)
    (value type-eq-decl nil Hoare_logic nil)
    (triple_valid const-decl "bool" hoare_triples nil)
    (triple_holds const-decl "bool" hoare_triples nil)
    (last const-decl "state" Hoare_logic nil)
    (first const-decl "state" Hoare_logic nil)
    (program type-decl nil Hoare_logic nil)
    (assertion type-eq-decl nil hoare_triples nil))
   shostak))
 (Hoare_Completeness 0
  (Hoare_Completeness-1 "instantiating with wlp" 3796008635
   ("" (induct "S")
    (("1" (skeep)
      (("1" (inst + "skip_step(mkTriple(wlp(skip)(Q), skip, Q))")
        (("1" (grind)
          (("1" (apply-extensionality)
            (("1" (grind)
              (("1" (inst - "(: x!1, x!1 :)")
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2"
          (inst +
           "assign_step(mkTriple(wlp(assign(assign1_var))(Q), assign(assign1_var), Q))")
          (("2" (grind)
            (("2" (apply-extensionality)
              (("2" (grind)
                (("2" (inst - "(: x!1, assign1_var(x!1) :)")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (inst - "Q")
          (("3" (inst - "Q")
            (("3" (skosimp*)
              (("3"
                (inst +
                 "mkpreProof_ift_step((IF IF1_var THEN IF2_var ELSE IF3_var ENDIF), IF1_var, Q, M!1, M!2)")
                (("3" (lemma "wlp_cond")
                  (("3" (inst - "IF1_var" "Q" "IF2_var" "IF3_var")
                    (("3" (decompose-equality -1)
                      (("3" (grind)
                        (("1" (apply-extensionality 1)
                          (("1" (delete 2) (("1" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (apply-extensionality 1)
                          (("2" (delete 2) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep)
      (("4" (skeep)
        (("4" (inst - "Q")
          (("4" (skeep)
            (("4"
              (inst +
               "while_step(mkTriple(wlp(doubletimes1_var ** doubletimes2_var)(Q),
                        doubletimes1_var ** doubletimes2_var, Q), M)")
              (("4" (lemma "wlp_is_inv")
                (("4"
                  (inst -1 "doubletimes1_var" "Q"
                   "doubletimes1_var ** doubletimes2_var"
                   " doubletimes2_var")
                  (("4" (smash)
                    (("4" (auto-rewrite-defs)
                      (("4" (stop-rewrite "[||]")
                        (("4" (smash)
                          (("1" (apply-extensionality)
                            (("1" (iff) (("1" (postpone) nil nil))
                              nil))
                            nil)
                           ("2" (postpone) nil nil)
                           ("3" (postpone) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep)
      (("5" (skeep)
        (("5" (inst -1 "Q")
          (("5" (inst -2 "Q")
            (("5" (skosimp*)
              (("5"
                (inst +
                 "seq_step(mkTriple(wlp(doublesharp1_var)(Q), doublesharp1_var, Q), M!1, M!2)")
                (("5" (lemma "wlp_seq")
                  (("5"
                    (inst - "Q" "doublesharp1_var" "doublesharp2_var")
                    (("5" (grind)
                      (("1" (postpone) nil nil)
                       ("2" (postpone) nil nil)
                       ("3" (postpone) nil nil)
                       ("4" (postpone) nil nil)
                       ("5" (postpone) nil nil)
                       ("6" (postpone) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil)))

